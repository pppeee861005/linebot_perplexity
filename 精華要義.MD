# LINE Bot AI 精華要義

本文檔整理了 `main.py` 中關鍵程式碼的解釋與最佳實務。

## 目錄

- [錯誤處理與配置](#錯誤處理與配置)
- [對話管理器](#對話管理器)
- [觸發關鍵字檢查](#觸發關鍵字檢查)
- [兩階段觸發檢查](#兩階段觸發檢查)
- [歷史字符串構建](#歷史字符串構建)
- [JSON 結構驗證](#json-結構驗證)

---

## 錯誤處理與配置

### 最佳實務：配置錯誤處理

1. **可恢復錯誤**：可以適當處理，或終結程式運行。
2. **無法恢復錯誤**：對於無法恢復的配置錯誤，應該讓程式失敗。
3. **錯誤傳播**：使用 `raise` 將異常向上傳播，讓呼叫者知道初始化失敗，可能會導致更多問題。

---

## 對話管理器

### 訊息限制機制

**程式碼位置**：`ConversationManager.add_message()`

**解釋**：

- `self.conversations[user_id]` 是該使用者的訊息列表
- `self.max_messages` 預設為 4（`max_exchanges=2 * 2`）
- 當訊息數量超過限制時，使用切片 `[-self.max_messages:]` 保留最後 4 條訊息
- 這是 FIFO（先進先出）機制，只保留最新的對話內容

---

## 觸發關鍵字檢查

### 單一關鍵字檢查邏輯

**程式碼**：
```python
return any(message.strip().startswith(keyword) for keyword in TriggerFilter.TRIGGER_KEYWORDS)
```

**解釋**：

- `message.strip()` - 移除訊息前後的空白字符
- `.startswith(keyword)` - 檢查訊息是否以指定關鍵字開頭
- `for keyword in TriggerFilter.TRIGGER_KEYWORDS` - 對關鍵字列表進行迭代（`["@助教", "@請查詢"]`）
- `any(...)` - 如果至少有一個條件為真，就返回 `True`，否則返回 `False`

這是生成器表達式（generator expression）的應用，用來判斷用戶訊息是否應該觸發 AI 回應。

---

## 兩階段觸發檢查

### 第120行：兩階段檢查流程

**程式碼**：
```python
@staticmethod
def is_triggered(message):
    """檢查訊息是否以任何支援的關鍵字開頭"""
    return any(message.strip().startswith(keyword) for keyword in TriggerFilter.TRIGGER_KEYWORDS)

@staticmethod
def get_trigger_type(message):
    """取得觸發的關鍵字類型"""
    for keyword in TriggerFilter.TRIGGER_KEYWORDS:
        if message.strip().startswith(keyword):
            return keyword
    return None
```

**解釋**：

這兩個方法形成一個兩階段的檢查流程：

#### 1. `is_triggered()` - 快速篩選
**目的**：快速判斷訊息是否需要處理
- 使用 `any()` 在找到第一個匹配時就停止，提高效率
- 如果訊息沒有任何關鍵字，直接忽略，不浪費進一步處理

#### 2. `get_trigger_type()` - 取得具體類型
**目的**：確定是哪種觸發模式，進行不同處理
- 如果找到匹配的關鍵字，就立即返回該關鍵字
- 如果循環結束都沒找到匹配，就返回 `None` 表示「無匹配」

### 程式流程示例：

```python
# 第一階段：檢查是否需要處理
if not TriggerFilter.is_triggered(user_message):
    return  # 忽略訊息

# 第二階段：確定處理方式
trigger_type = TriggerFilter.get_trigger_type(user_message)
if trigger_type == "@請查詢":
    # 直接搜尋模式
elif trigger_type == "@助教":
    # AI 對話模式
```

### 設計原因：

1. **效能考量**：先用高效的 `any()` 做初步篩選
2. **邏輯分離**：布林檢查 vs 具體值取得
3. **程式流程**：符合「先過濾，再分類」的邏輯

---

## 歷史字符串構建

### 對話歷史處理

**程式碼位置**：處理訊息時的歷史構建

**目的**：構建一個歷史字符串，用來表示對話歷史記錄。

**分解說明**：

- `history` 是一個列表，包含對話歷史中的訊息
- `len(history) > 1` 檢查歷史是否有多於一條訊息
- **有多條訊息時**：`"\n".join(history[:-1])` 會將歷史中除了最後一條外的所有訊息，用換行符 `\n` 連接起來
  - `history[:-1]` 切片表示從頭到倒數第二個元素（不包括最後一個）
- **沒有或只有一條訊息時**：使用 `"（無歷史）"` 表示無歷史

**設計考量**：用於顯示過去的對話內容，但排除當前的訊息（最後一條）。在聊天機器人中，這可以避免重複顯示正在處理的訊息。

---

## JSON 結構驗證

### 搜尋決策驗證

**程式碼位置**：Gemini 回應解析後的驗證

**目的**：驗證 `search_decision` 的 JSON 結構是否正確，並提供安全預設值。

**分解說明**：

#### 1. 條件檢查：
- `isinstance(search_decision, dict)`：確認 `search_decision` 是一個字典
- `"search" not in search_decision`：確認字典中包含 `"search"` 鍵

#### 2. 如果條件為真（結構無效）：
- 記錄警告日誌：`"無效的搜尋決策格式: {search_decision}"`
- 設定預設值：`search_decision = {"search": "N", "keyword": ""}`
  - `"search": "N"` 表示「不搜尋」
  - `"keyword": ""` 表示空的關鍵字

#### 3. 設計目的：
- 防止程式因為不正確的資料格式而崩潰
- 提供合理的預設行為（不進行搜尋）
- 記錄問題以便除錯

這是常見的防禦性程式設計模式，確保程式在接收到意外資料時仍能正常運作。

----
@staticmethod
def extract_content(message):
    """提取關鍵字之後的內容。"""
    trigger_type = Trigger_Filter.get_trigger_type(message)  # 取得觸發關鍵字，如 "@助教"
    
    if trigger_type:  # 如果有找到關鍵字
        content = message[len(trigger_type):].strip()  # 切片取得關鍵字後的內容並移除空白
        return content
    return None  # 如果沒有關鍵字，返回 None


----
這個 `search_decision = {"search": "N", "keyword": ""}` 是搜尋決策的預設值，表示「不進行搜尋」。

**含義**：

- `"search": "N"` - 不進行網路搜尋
- `"keyword": ""` - 空的搜尋關鍵字

**使用場景**：

這是在程式碼中作為「安全預設值」出現的，當以下情況發生時會設定為這個值：

1. **Gemini API 回應失敗**：當 `gemini_client.models.generate_content()` 呼叫失敗時
2. **JSON 解析失敗**：當 `json.loads()` 無法解析 Gemini 的回應時
3. **結構驗證失敗**：當回應的 JSON 格式不正確（不是字典或缺少 "search" 鍵）時

**設計目的**：

- **防禦性程式設計**：確保程式不會因為 AI 決策錯誤而崩潰
- **安全預設**：在無法確定是否需要搜尋時，選擇不搜尋（避免不必要的 API 呼叫和成本）
- ** graceful degradation**：即使 AI 部分失敗，程式仍能繼續運作，只是沒有搜尋功能

這樣可以確保聊天機器人在任何情況下都能提供基本回應，而不會因為搜尋決策的錯誤而中斷服務。


----
`isinstance` 是 Python 的內建函數，用來檢查物件是否為指定類型或類型的實例。

**在這個程式碼中的用法**：

```python
if not isinstance(search_decision, dict) or "search" not in search_decision or "keyword" not in search_decision:
```

**分解說明**：

1. **`isinstance(search_decision, dict)`**
   - 檢查 `search_decision` 是否為字典類型 (`dict`)
   - 如果是字典，返回 `True`；否則返回 `False`

2. **完整條件檢查**：
   - `not isinstance(search_decision, dict)` - 如果不是字典
   - `"search" not in search_decision` - 如果缺少 `"search"` 鍵
   - `"keyword" not in search_decision` - 如果缺少 `"keyword"` 鍵

3. **如果任一條件為真**：
   - 記錄警告日誌
   - 重設為預設值：`{"search": "N", "keyword": ""}`

**設計目的**：

- **類型安全**：確保 `search_decision` 是字典
- **結構完整性**：確保包含必要的鍵 `"search"` 和 `"keyword"`
- **防禦性驗證**：防止因為資料格式錯誤導致程式崩潰

`isinstance` 常用於執行時期類型檢查，確保變數的實際類型符合預期。
